<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Alien Raid</title>
  <style>
    html, body { height: 100%; margin: 0; background:#05060a; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .wrap { height:100%; display:grid; place-items:center; }
    canvas { image-rendering: pixelated; border: 2px solid #2b2f3a; background:#070813; box-shadow: 0 0 30px rgba(0,0,0,.6); }
    .hint { color:#8ea0c8; font-size:12px; margin-top:10px; text-align:center; }
    .hint b { color:#d8e2ff; }
  </style>
</head>
<body>
<div class="wrap">
  <div>
    <canvas id="game" width="480" height="640"></canvas>
    <div class="hint">
      Move: <b>← →</b> / <b>A D</b> • Shoot: <b>Space</b> • Pause: <b>P</b> • Restart: <b>R</b> • Audio: <b>M</b> • Skip Splash: <b>B</b>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  const LAST_LEVEL = 10;

  const rand = (a=1,b=0)=>Math.random()*(a-b)+b;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  const UI = {
    bg1: "#070813",
    ui:  "#d8e2ff",
    dim: "#8ea0c8",
    p:   "#7CFFB2",
    shot:"#E7F3FF",
    danger:"#ffb3c1"
  };

  const THEMES = [
    { name:"NEBULA",  colors:["#7AA2FF","#FFC857","#FF6B8A"], enemyStyle:0, bgTint:"rgba(70,90,180,0.10)",  behavior:"nebula"  },
    { name:"TOXIC",   colors:["#9BFF7A","#4DFFB8","#E7FF7A"], enemyStyle:1, bgTint:"rgba(90,180,120,0.10)", behavior:"toxic"   },
    { name:"EMBER",   colors:["#FF7A4D","#FFC14D","#FF4D9B"], enemyStyle:2, bgTint:"rgba(180,90,70,0.10)",  behavior:"ember"   },
    { name:"ICE",     colors:["#7AF5FF","#7AA2FF","#B7C9FF"], enemyStyle:3, bgTint:"rgba(70,160,180,0.10)", behavior:"ice"     },
    { name:"VOID",    colors:["#C77DFF","#7A2DFF","#FF4DD8"], enemyStyle:4, bgTint:"rgba(120,70,180,0.10)", behavior:"void"    },
    { name:"CIRCUIT", colors:["#FFEF5A","#55FFB9","#55A7FF"], enemyStyle:5, bgTint:"rgba(170,170,70,0.10)",  behavior:"circuit" },
  ];

  // ===== Input =====
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);
    if (k === " " || k === "arrowup") e.preventDefault();
    if (k === "p") togglePause();
    if (k === "m") toggleMute();
    if (k === "r") { if (state.gameOver || state.victory) restart(); }
    if (k === "b" && state.splash > 0) state.splash = 0; // skip splash
    if (!audio.started) audio.start(); // user gesture requirement
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // ===== Audio =====
  const audio = {
    started:false, muted:false, ctx:null, master:null, musicGain:null, sfxGain:null,
    timer:null, step:0,

    start(){
      if (this.started) return;
      this.started = true;
      const A = new (window.AudioContext || window.webkitAudioContext)();
      this.ctx = A;

      const master = A.createGain(); master.gain.value = 0.9; master.connect(A.destination);
      this.master = master;

      this.musicGain = A.createGain(); this.musicGain.gain.value = 0.22; this.musicGain.connect(master);
      this.sfxGain   = A.createGain(); this.sfxGain.gain.value   = 0.55; this.sfxGain.connect(master);

      this.playLevelMusic(1);
    },

    setMuted(on){
      this.muted = on;
      if (!this.started) return;
      this.master.gain.setTargetAtTime(on ? 0 : 0.9, this.ctx.currentTime, 0.01);
    },

    beep({freq=440,dur=0.08,type="square",gain=0.12,slideTo=null,slideTime=0.06,pan=0}={}, bus="sfx"){
      if (!this.started || this.muted) return;
      const A=this.ctx;
      const o=A.createOscillator(); o.type=type; o.frequency.setValueAtTime(freq, A.currentTime);
      if (slideTo != null) o.frequency.exponentialRampToValueAtTime(Math.max(1, slideTo), A.currentTime+slideTime);

      const g=A.createGain();
      g.gain.setValueAtTime(0.0001, A.currentTime);
      g.gain.exponentialRampToValueAtTime(gain, A.currentTime+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, A.currentTime+dur);

      let out=g;
      if (A.createStereoPanner){
        const p=A.createStereoPanner(); p.pan.value=pan; g.connect(p); out=p;
      }

      o.connect(g);
      out.connect(bus==="music" ? this.musicGain : this.sfxGain);
      o.start(); o.stop(A.currentTime+dur+0.02);
    },

    noise({dur=0.10,gain=0.09,pan=0}={}, bus="sfx"){
      if (!this.started || this.muted) return;
      const A=this.ctx;
      const N=Math.floor(A.sampleRate*dur);
      const buf=A.createBuffer(1,N,A.sampleRate);
      const d=buf.getChannelData(0);
      for (let i=0;i<N;i++){ const t=i/N; d[i]=(Math.random()*2-1)*(1-t); }

      const src=A.createBufferSource(); src.buffer=buf;
      const g=A.createGain(); g.gain.value=gain;

      let out=g;
      if (A.createStereoPanner){
        const p=A.createStereoPanner(); p.pan.value=pan; g.connect(p); out=p;
      }

      src.connect(g); out.connect(bus==="music" ? this.musicGain : this.sfxGain);
      src.start(); src.stop(A.currentTime+dur+0.02);
    },

    getLevelPreset(level){
      const L = [
        { bpm:132, lead:[440,523,587,659,587,523,494,523, 440,392,440,523,587,523,494,440], bass:[110,110,131,131,147,147,131,131, 98,98,110,110,131,131,110,110] },
        { bpm:148, lead:[523,659,784,659,587,659,523,494, 523,659,784,880,784,659,587,523], bass:[131,131,147,147,165,165,147,147, 110,110,131,131,147,147,131,131] },
        { bpm:124, lead:[392,440,494,523,494,440,392,349, 392,440,494,523,587,523,494,440], bass:[98,98,110,110,123,123,110,110, 87,87,98,98,110,110,98,98] },
        { bpm:136, lead:[587,659,587,523,494,523,587,659, 698,659,587,523,494,440,494,523], bass:[147,147,165,165,147,147,131,131, 110,110,131,131,147,147,131,131] },
        { bpm:120, lead:[494,523,587,523,494,440,392,440, 494,523,587,659,587,523,494,440], bass:[123,123,110,110,98,98,110,110, 87,87,98,98,110,110,123,123] },
        { bpm:156, lead:[659,784,880,784,659,587,523,587, 659,784,880,988,880,784,659,587], bass:[165,165,147,147,131,131,147,147, 110,110,131,131,147,147,165,165] },
        { bpm:140, lead:[440,494,523,587,523,494,440,392, 440,494,523,659,523,494,440,392], bass:[110,110,123,123,131,131,123,123, 98,98,110,110,123,123,110,110] },
        { bpm:128, lead:[523,587,659,587,523,494,523,587, 659,698,659,587,523,494,440,494], bass:[131,131,147,147,131,131,110,110, 98,98,110,110,131,131,110,110] },
        { bpm:144, lead:[392,440,392,349,392,440,494,523, 494,440,392,349,330,349,392,440], bass:[98,98,110,110,98,98,87,87, 82,82,87,87,98,98,110,110] },
        { bpm:150, lead:[587,659,784,659,587,523,494,523, 587,659,784,880,784,659,587,523], bass:[147,147,165,165,147,147,131,131, 110,110,131,131,147,147,165,165] },
      ];
      return L[(level-1) % L.length];
    },

    getBossPreset(level){
      const V = [
        { bpm:108, lead:[392,370,349,330,349,370,392,311, 392,370,349,330,294,311,349,262], bass:[98,98,92,92,87,87,92,92, 82,82,98,98,92,92,87,87] },
        { bpm:112, lead:[330,311,294,277,294,311,330,262, 330,311,294,277,247,262,294,220], bass:[82,82,78,78,73,73,78,78, 65,65,73,73,78,78,82,82] },
        { bpm:104, lead:[440,415,392,370,392,415,440,349, 440,415,392,370,330,349,392,262], bass:[110,110,104,104,98,98,104,104, 87,87,98,98,104,104,110,110] },
      ];
      return V[(level-1) % V.length];
    },

    playPreset(p, mode){
      if (!this.started) return;
      if (this.timer) clearTimeout(this.timer);
      this.step = 0;

      const bpm = p.bpm;
      const stepDur = 60 / bpm / 2;

      const leadType = (mode==="boss") ? "square" : "square";
      const bassType = (mode==="boss") ? "sawtooth" : "triangle";
      const leadGain = (mode==="boss") ? 0.088 : 0.070;
      const bassGain = (mode==="boss") ? 0.050 : 0.058;

      const tick = () => {
        if (!this.started) return;
        const i = this.step++ % p.lead.length;

        this.beep({freq:p.lead[i], dur:stepDur*0.92, type:leadType, gain:leadGain, pan:-0.10}, "music");
        this.beep({freq:p.bass[i], dur:stepDur*0.98, type:bassType, gain:bassGain, pan: 0.10}, "music");

        if (mode==="boss" && (i % 4 === 0)) this.noise({dur:0.04, gain:0.02}, "music");

        this.timer = setTimeout(tick, stepDur*1000);
      };
      tick();
    },

    playLevelMusic(level){ this.playPreset(this.getLevelPreset(level), "level"); },
    playBossMusic(level){ this.playPreset(this.getBossPreset(level), "boss"); },

    playVictory(){
      this.playPreset({
        bpm:160,
        lead:[523,659,784,988,784,659,523,659, 784,988,1175,988,784,659,523,784],
        bass:[131,131,165,165,131,131,110,110, 98,98,110,110,131,131,165,165],
      }, "level");
      this.beep({freq:1046, slideTo:1568, slideTime:0.10, dur:0.16, type:"square", gain:0.10}, "music");
    }
  };

  function toggleMute(){ audio.setMuted(!audio.muted); }

  // ===== Game State =====
  const state = {
    t:0, last:0, dt:0,
    paused:false,
    gameOver:false,
    victory:false,

    splash: 8.0,

    level:1,
    score:0,
    hi: Number(localStorage.getItem("alienraid_hi") || 0),
    lives:3,

    themeIdx:0,

    waveClearedAt:0,

    bossSpawned:false,
    bossIncoming:false,
    bossWarning:0,
    bossTryAt:0,
    bossForceAt:0,
    victoryPhase:"dance",
    vDanceT:0,
    vBoomT:0,
  };

  // ===== Entities =====
  const player = { x:W/2, y:H-60, w:18, h:16, speed:240, fireCd:0, invuln:0 };
  const bullets = [];
  const eBullets = [];
  const enemies = [];
  const particles = [];
  let boss = null;

  const BOSS_DAMAGE = 6;
  const BOSS_HP_MULT = 0.70;

  const enemyBulletCap = (lvl)=> clamp(16 + lvl*2, 16, 34);

  // Stars
  const stars = Array.from({length:90},()=>({ x:rand(W), y:rand(H), z:rand(1,0.2), s:rand(2,0.6) }));

  // Formation
  const formation = { x:W/2, y:120, dx:1, speed:28, swing:34, drop:18, edgePad:60, attackTimer:0 };

  // ===== Helpers =====
  function rectsOverlap(a,b){
    return a.x-a.w/2 < b.x+b.w/2 &&
           a.x+a.w/2 > b.x-b.w/2 &&
           a.y-a.h/2 < b.y+b.h/2 &&
           a.y+a.h/2 > b.y-b.h/2;
  }

  function addExplosion(x,y,color,amount=18){
    for (let i=0;i<amount;i++){
      particles.push({
        x,y,
        vx: rand(160,-160),
        vy: rand(160,-160),
        life: rand(0.75,0.25),
        t:0,
        c: color
      });
    }
  }

  function difficulty(level){
    const l = Math.max(1, level);
    return {
      formationSpeed: clamp(28+(l-1)*3.0, 28, 75),
      swing:          clamp(34+(l-1)*1.2, 34, 60),
      attackRate:     clamp(2.4-(l-1)*0.12, 0.70, 2.4),

      enemyBulletSpeed: clamp(170+(l-1)*10, 170, 330),

      fireEvery: clamp(4.0-(l-1)*0.18, 1.65, 4.0),
      fireBiasFormation: clamp(0.04+(l-1)*0.007, 0.04, 0.12),
      fireBiasAttack:    clamp(0.14+(l-1)*0.018, 0.14, 0.36),

      diveAy: clamp(140+(l-1)*10, 140, 275),
      diveAx: clamp(100+(l-1)*6, 100, 190),

      hpBonus: (l>=5?1:0) + (l>=10?1:0),

      bossHp: Math.max(6, Math.floor((14 + (l-1)*3) * BOSS_HP_MULT)),
      bossFireEvery: clamp(2.2 - (l-1)*0.06, 1.2, 2.2),
      bossBulletSpeed: clamp(210 + (l-1)*10, 210, 380),
    };
  }

  function shoot(){
    bullets.push({ x:player.x, y:player.y-12, vx:0, vy:-430, w:3, h:10 });
    audio.beep({freq:780, slideTo:520, slideTime:0.07, dur:0.09, type:"square", gain:0.13, pan:(player.x/W)*1.2-0.6});
  }

  function togglePause(){
    if (state.gameOver || state.victory) return;
    state.paused = !state.paused;
  }

  function restart(){
    state.t=0; state.last=0; state.dt=0;
    state.paused=false;
    state.gameOver=false;
    state.victory=false;
    state.splash=8.0;

    state.level=1;
    state.score=0;
    state.lives=3;

    state.waveClearedAt=0;

    state.victoryPhase="dance";
    state.vDanceT=0;
    state.vBoomT=0;

    player.x=W/2; player.invuln=1.2; player.fireCd=0;

    spawnWave(state.level);
  }

  // ===== Theme behaviors =====
  function applyThemeOnSpawnEnemy(e, theme){
    e.shield = (theme.behavior === "ice") ? (Math.random() < 0.30) : false;
    e.tpCd = rand(3.0, 1.6);
    e.tpFlash = 0;
    e.zzPhase = rand(Math.PI*2, 0);
    e.fireCd = rand(4.2, 2.6);
  }

  function behaviorAttackUpdate(e, dt, theme){
    const d = difficulty(state.level);

    if (theme.behavior === "toxic"){
      const amp = 70, freq = 3.2;
      e.x += Math.sin((state.t*freq) + e.zzPhase) * amp * dt;
      e.x = clamp(e.x, 20, W-20);
    }

    if (theme.behavior === "ember"){
      e.ay += 22 * dt;
      e.ay = Math.min(e.ay, d.diveAy * 1.35);
      const steer = clamp((player.x - e.x)/260, -1, 1);
      e.ax += steer * 50 * dt;
      e.ax = clamp(e.ax, -d.diveAx*1.1, d.diveAx*1.1);
    }

    if (theme.behavior === "void"){
      e.tpCd -= dt;
      if (e.tpCd <= 0){
        e.tpFlash = 0.20;
        e.tpCd = rand(3.2, 1.9);
      }
      if (e.tpFlash > 0){
        e.tpFlash -= dt;
        if (e.tpFlash <= 0){
          const hop = (Math.random()<0.5 ? -1 : 1) * rand(90, 60);
          const nx = clamp(e.x + hop, 26, W-26);
          if (Math.abs(nx - e.x) > 30) e.x = nx;
        }
      }
    }
  }

  function behaviorShootVector(e, theme){
    let vx = 0;
    let vy = difficulty(state.level).enemyBulletSpeed;

    if (theme.behavior === "circuit"){
      const dx = clamp((player.x - e.x) / 260, -0.65, 0.65);
      vx = dx * vy * 0.55;
      vy = Math.max(140, vy * 0.92);
    }
    return {vx, vy};
  }

  function enemyShoot(e, theme){
    if (eBullets.length >= enemyBulletCap(state.level)) return;
    const v = behaviorShootVector(e, theme);
    eBullets.push({ x:e.x, y:e.y+10, vx:v.vx, vy:v.vy, w:3, h:10, from:"enemy" });
    audio.beep({freq:260, slideTo:180, slideTime:0.06, dur:0.08, type:"square", gain:0.055, pan:(e.x/W)*1.2-0.6});
  }

  // ===== Boss =====
  function startBossSequence(){
    state.bossIncoming = true;
    state.bossWarning = 1.0;
    if (audio.started) audio.playBossMusic(state.level);
    audio.beep({freq:330, slideTo:660, slideTime:0.10, dur:0.12, type:"square", gain:0.10});
    audio.beep({freq:330, slideTo:660, slideTime:0.10, dur:0.12, type:"square", gain:0.10});
  }

  function spawnBossNow(){
    const d = difficulty(state.level);
    const theme = THEMES[state.themeIdx];

    boss = {
      x: W/2,
      y: -60,
      w: 78, h: 38,
      hp: d.bossHp,
      maxHp: d.bossHp,
      alive:true,

      vx:0, vy:0,
      tx: rand(W-90, 90),
      ty: rand(175, 70),
      retarget: rand(1.6, 0.9),

      entryT: 1.0,
      targetY: 92,

      fireCd: rand(d.bossFireEvery, d.bossFireEvery*0.6),
      telegraph: 0,
      flash: 0,

      c1: theme.colors[0],
      c2: theme.colors[1],
      c3: theme.colors[2] || theme.colors[0],

      pattern: theme.behavior
    };

    audio.beep({freq:220, slideTo:440, slideTime:0.18, dur:0.22, type:"triangle", gain:0.12});
  }

  function ensureBossWillSpawn(){
    if (state.bossSpawned) return;
    const aliveEnemies = enemies.filter(e=>e.alive).length;
    if (state.t >= state.bossTryAt || aliveEnemies <= state.bossForceAt){
      state.bossSpawned = true;
      startBossSequence();
    }
  }

  function bossShoot(){
    if (!boss || !boss.alive) return;
    if (eBullets.length >= enemyBulletCap(state.level)) return;

    const d = difficulty(state.level);
    boss.telegraph = 0.12;

    const sp = d.bossBulletSpeed;
    const shots = [
      {vx:-0.25*sp, vy:0.95*sp},
      {vx: 0.00*sp, vy:1.00*sp},
      {vx: 0.25*sp, vy:0.95*sp},
    ];

    if (boss.pattern === "toxic"){
      shots.push({vx:0, vy:0.80*sp, wave:true});
    } else if (boss.pattern === "circuit"){
      const dx = clamp((player.x - boss.x)/260, -0.8, 0.8);
      shots.push({vx: dx*sp*0.55, vy:0.92*sp});
    } else if (boss.pattern === "void"){
      shots.push({vx:0, vy:1.06*sp});
    } else if (boss.pattern === "ice"){
      shots.push({vx:0, vy:0.72*sp});
    } else if (boss.pattern === "ember"){
      shots.push({vx:0, vy:1.10*sp});
    }

    for (const s of shots){
      if (eBullets.length >= enemyBulletCap(state.level)) break;
      eBullets.push({
        x: boss.x + rand(10,-10),
        y: boss.y + 20,
        vx: s.vx, vy: s.vy,
        w: 4, h: 12,
        from:"boss",
        wave: !!s.wave,
        wavePhase: rand(Math.PI*2,0)
      });
    }

    audio.beep({freq:160, slideTo:120, slideTime:0.10, dur:0.11, type:"square", gain:0.075, pan:(boss.x/W)*1.2-0.6});
    audio.noise({dur:0.06, gain:0.05, pan:(boss.x/W)*1.2-0.6});
  }

  function updateBoss(dt){
    if (!boss || !boss.alive) return;

    if (boss.entryT > 0){
      boss.entryT = Math.max(0, boss.entryT - dt);
      const p = 1 - boss.entryT/1.0;
      const eased = 1 - Math.pow(1 - p, 3);
      boss.y = -60 + (boss.targetY + 60) * eased;
      boss.telegraph = 0;
      return;
    }

    boss.retarget -= dt;
    if (boss.retarget <= 0){
      boss.retarget = rand(1.6, 0.8);
      boss.tx = rand(W-90, 90);
      boss.ty = rand(185, 70);
    }

    const dx = boss.tx - boss.x;
    const dy = boss.ty - boss.y;

    const ax = clamp(dx * 0.9, -270, 270);
    const ay = clamp(dy * 0.9, -230, 230);

    boss.vx += ax * dt;
    boss.vy += ay * dt;

    boss.vx *= (1 - 2.2*dt);
    boss.vy *= (1 - 2.2*dt);

    const maxV = 165;
    boss.vx = clamp(boss.vx, -maxV, maxV);
    boss.vy = clamp(boss.vy, -maxV, maxV);

    boss.x += boss.vx * dt;
    boss.y += boss.vy * dt;

    boss.x = clamp(boss.x, 80, W-80);
    boss.y = clamp(boss.y, 60, 210);

    boss.flash = Math.max(0, boss.flash - dt);
    if (boss.pattern === "void"){
      if (Math.random() < 0.0035 && boss.flash <= 0) boss.flash = 0.18;
      if (boss.flash > 0 && boss.flash < 0.02){
        boss.x = clamp(boss.x + (Math.random()<0.5?-1:1)*rand(90,60), 80, W-80);
      }
    }

    boss.telegraph = Math.max(0, boss.telegraph - dt);

    const d = difficulty(state.level);
    boss.fireCd -= dt;
    if (boss.fireCd <= 0){
      bossShoot();
      boss.fireCd = d.bossFireEvery + rand(0.7, -0.2);
    }
  }

  // ===== Wave Spawn =====
  function spawnWave(level){
    enemies.length = 0;
    bullets.length = 0;
    eBullets.length = 0;
    particles.length = 0;
    boss = null;

    state.bossSpawned = false;
    state.bossIncoming = false;
    state.bossWarning = 0;

    state.themeIdx = (level-1) % THEMES.length;
    const theme = THEMES[state.themeIdx];
    const d = difficulty(level);

    if (audio.started) audio.playLevelMusic(level);

    state.bossTryAt = state.t + rand(11, 7);
    state.bossForceAt = clamp(6 - Math.floor((level-1)/3), 3, 6);

    formation.x = W/2;
    formation.y = 120;
    formation.dx = 1;
    formation.speed = d.formationSpeed;
    formation.swing = d.swing;
    formation.attackTimer = 1.6;

    const rows = 4 + Math.min(2, Math.floor((level-1)/2));
    const cols = 8;
    const gapX = 42, gapY = 34;

    const startX = W/2 - (cols-1)*gapX/2;
    const startY = 90;

    const rowHp = (r, rows) => {
      const base = (r < 2) ? 1 : (r < rows-1 ? 1 : 2);
      return base + d.hpBonus;
    };
    const rowPts = (hp) => 50 + hp*35;

    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const hp = rowHp(r, rows);
        const e = {
          baseX: startX + c*gapX,
          baseY: startY + r*gapY,
          x:0, y:0,
          w:18, h:14,
          hp, maxHp:hp,
          c: theme.colors[r % theme.colors.length],
          pts: rowPts(hp),
          alive:true,
          mode:"formation",
          ax:0, ay:0,
          style: theme.enemyStyle,
          shield:false,
          tpCd:0,
          tpFlash:0,
          zzPhase:0,
          fireCd: rand(4.2, 2.6)
        };
        applyThemeOnSpawnEnemy(e, theme);
        enemies.push(e);
      }
    }
  }

  function pickAttacker(){
    const alive = enemies.filter(e => e.alive && e.mode === "formation");
    if (!alive.length) return null;
    alive.sort((a,b)=> (b.baseY - a.baseY) + rand(0.6,-0.6));
    return alive[0];
  }

  // ===== Enemy evolution (tier variants) =====
  function enemyVariantFor(style, level){
    const tier = Math.min(3, Math.floor((level - 1) / 2));
    const map = {
      0: [0,1,2,2],
      1: [0,1,2,2],
      2: [0,1,2,2],
      3: [0,1,2,2],
      4: [0,1,2,2],
      5: [0,1,2,2],
    };
    return (map[style] || [0,1,2,2])[tier];
  }

  // ===== Loop =====
  function frame(ts){
    if (!state.last) state.last = ts;
    state.dt = Math.min(0.033, (ts - state.last)/1000);
    state.last = ts;

    if (!state.paused && !state.gameOver && !state.victory) update(state.dt);
    if (!state.paused && state.victory) updateVictory(state.dt);
    draw();

    requestAnimationFrame(frame);
  }

  // init
  spawnWave(state.level);
  requestAnimationFrame(frame);

  function updateStars(dt){
    for (const s of stars){
      s.y += (40*s.z) * dt;
      if (s.y > H){ s.y = -2; s.x = rand(W); }
    }
  }

  function update(dt){
    state.t += dt;
    updateStars(dt);

    if (state.splash > 0){
      state.splash = Math.max(0, state.splash - dt);
      return;
    }

    if (state.bossWarning > 0){
      state.bossWarning = Math.max(0, state.bossWarning - dt);
      if (state.bossWarning === 0 && state.bossIncoming){
        state.bossIncoming = false;
        spawnBossNow();
      }
    }

    const left  = keys.has("arrowleft") || keys.has("a");
    const right = keys.has("arrowright") || keys.has("d");
    let mv=0; if (left) mv-=1; if (right) mv+=1;

    player.x += mv * player.speed * dt;
    player.x = clamp(player.x, 20, W-20);

    player.fireCd -= dt;
    if ((keys.has(" ") || keys.has("space")) && player.fireCd <= 0){
      shoot();
      player.fireCd = 0.16;
    }

    ensureBossWillSpawn();
    updateBoss(dt);

    const d = difficulty(state.level);
    const swing = Math.sin(state.t*0.9) * formation.swing;

    formation.x += formation.dx * formation.speed * dt;
    const leftEdge  = formation.x - formation.edgePad;
    const rightEdge = formation.x + formation.edgePad;
    if (leftEdge < 40) { formation.dx = 1; formation.y += formation.drop; }
    if (rightEdge > W-40){ formation.dx = -1; formation.y += formation.drop; }

    formation.attackTimer -= dt;
    if (formation.attackTimer <= 0){
      const a = pickAttacker();
      if (a){
        a.mode = "attack";
        const dirX = clamp((player.x - (formation.x + a.baseX - W/2)) / 260, -1, 1);
        a.ax = dirX * d.diveAx;
        a.ay = d.diveAy;
      }
      formation.attackTimer = d.attackRate;
    }

    const theme = THEMES[state.themeIdx];

    for (const e of enemies){
      if (!e.alive) continue;

      if (e.mode === "formation"){
        e.x = (formation.x + (e.baseX - W/2)) + swing * (e.baseY/220);
        e.y = (formation.y + (e.baseY - 120));
      } else if (e.mode === "attack"){
        e.x += e.ax * dt;
        e.y += e.ay * dt;
        e.x += Math.sin((state.t*8)+e.baseX) * 18 * dt;
        behaviorAttackUpdate(e, dt, theme);
        if (e.y > H + 40) e.mode = "return";
      } else if (e.mode === "return"){
        const tx = (formation.x + (e.baseX - W/2));
        const ty = (formation.y + (e.baseY - 120));
        const dx = tx - e.x, dy = ty - e.y;
        const k = 3.2;
        e.x += dx * k * dt;
        e.y += dy * k * dt;
        if (Math.abs(dx)<3 && Math.abs(dy)<3) e.mode="formation";
      }

      e.fireCd -= dt;
      const fireBias = (e.mode === "attack") ? d.fireBiasAttack : d.fireBiasFormation;
      const fireEvery = d.fireEvery;
      if (e.fireCd <= 0){
        if (Math.random() < fireBias) enemyShoot(e, theme);
        e.fireCd = fireEvery + rand(0.9, -0.2);
      }
    }

    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      b.y += b.vy*dt;
      if (b.y < -20) bullets.splice(i,1);
    }
    for (let i=eBullets.length-1;i>=0;i--){
      const b=eBullets[i];
      if (b.wave) b.x += Math.sin((state.t*6)+b.wavePhase) * 45 * dt;
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      if (b.y > H+30 || b.x < -40 || b.x > W+40) eBullets.splice(i,1);
    }

    for (let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.t += dt;
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= (1-2.2*dt);
      p.vy *= (1-2.2*dt);
      if (p.t >= p.life) particles.splice(i,1);
    }

    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      let hit=false;

      if (boss && boss.alive && rectsOverlap({x:b.x,y:b.y,w:b.w,h:b.h}, boss)){
        hit=true;
        boss.hp -= BOSS_DAMAGE;
        boss.flash = 0.10;
        addExplosion(b.x,b.y, UI.shot, 10);
        audio.noise({dur:0.04,gain:0.05,pan:(b.x/W)*1.2-0.6});

        if (boss.hp <= 0){
          boss.alive=false;
          addExplosion(boss.x,boss.y,boss.c1, 30);
          addExplosion(boss.x+20,boss.y,boss.c2, 24);
          addExplosion(boss.x-20,boss.y,boss.c3, 24);
          state.score += 1200 + state.level*220;

          if (audio.started) audio.playLevelMusic(state.level);

          audio.beep({freq:260,slideTo:110,slideTime:0.16,dur:0.22,type:"square",gain:0.12});
          audio.noise({dur:0.10,gain:0.08});
        } else {
          state.score += 15;
        }
      }

      if (hit){ bullets.splice(i,1); continue; }

      for (const e of enemies){
        if (!e.alive) continue;
        if (rectsOverlap({x:b.x,y:b.y,w:b.w,h:b.h}, e)){
          hit=true;

          if (e.shield){
            e.shield = false;
            addExplosion(b.x,b.y,"#e7f3ff", 10);
            audio.beep({freq:520,slideTo:740,slideTime:0.06,dur:0.08,type:"triangle",gain:0.08,pan:(e.x/W)*1.2-0.6});
            state.score += 5;
          } else {
            e.hp -= 1;
            addExplosion(b.x,b.y, UI.shot, 10);
            audio.noise({dur:0.04,gain:0.05,pan:(e.x/W)*1.2-0.6});
            if (e.hp <= 0){
              e.alive=false;
              state.score += e.pts;
              addExplosion(e.x,e.y,e.c, 18);
              audio.beep({freq:220,slideTo:120,slideTime:0.10,dur:0.16,type:"square",gain:0.10,pan:(e.x/W)*1.2-0.6});
            } else {
              state.score += 8;
            }
          }
          break;
        }
      }

      if (hit) bullets.splice(i,1);
    }

    player.invuln = Math.max(0, player.invuln - dt);
    if (player.invuln <= 0){
      for (let i=eBullets.length-1;i>=0;i--){
        const b=eBullets[i];
        if (rectsOverlap({x:b.x,y:b.y,w:b.w,h:b.h}, player)){
          eBullets.splice(i,1);
          state.lives -= 1;
          player.invuln = 1.6;

          addExplosion(player.x, player.y, UI.p, 18);
          audio.noise({dur:0.16,gain:0.10,pan:(player.x/W)*1.2-0.6});
          audio.beep({freq:180,slideTo:80,slideTime:0.14,dur:0.22,type:"sawtooth",gain:0.12,pan:(player.x/W)*1.2-0.6});

          if (state.lives <= 0){
            state.gameOver = true;
            state.hi = Math.max(state.hi, state.score);
            localStorage.setItem("alienraid_hi", String(state.hi));
            if (audio.started) audio.playLevelMusic(1);
          }
          break;
        }
      }
    }

    const enemiesCleared = enemies.every(e=>!e.alive);
    const bossCleared = (!state.bossSpawned) ? false : (!boss || !boss.alive);

    if (enemiesCleared && !state.bossSpawned){
      state.bossSpawned = true;
      startBossSequence();
    }

    if (enemiesCleared && bossCleared){
      if (!state.waveClearedAt) state.waveClearedAt = state.t;

      if (state.t - state.waveClearedAt > 1.0){
        if (state.level >= LAST_LEVEL){
          state.victory = true;
          state.hi = Math.max(state.hi, state.score);
          localStorage.setItem("alienraid_hi", String(state.hi));
          if (audio.started) audio.playVictory();
        } else {
          state.level += 1;
          state.waveClearedAt = 0;
          spawnWave(state.level);
          player.invuln = 1.0;
          audio.beep({freq:440,slideTo:660,slideTime:0.12,dur:0.18,type:"triangle",gain:0.10});
        }
      }
    } else {
      state.waveClearedAt = 0;
    }

    if (state.score > state.hi){
      state.hi = state.score;
      localStorage.setItem("alienraid_hi", String(state.hi));
    }
  }

  function updateVictory(dt){
    state.t += dt;
    updateStars(dt);

    const theme = THEMES[state.themeIdx];

    if (state.victoryPhase === "dance"){
      state.vDanceT += dt;
      if (state.vDanceT > 2.2){
        state.victoryPhase = "boom";
        state.vBoomT = 0;

        const ax = W/2, ay = 360;
        addExplosion(ax, ay, theme.colors[0], 40);
        addExplosion(ax+10, ay-6, theme.colors[1], 34);
        addExplosion(ax-10, ay+6, theme.colors[2] || theme.colors[0], 34);

        if (audio.started){
          audio.noise({dur:0.14,gain:0.10});
          audio.beep({freq:220,slideTo:110,slideTime:0.12,dur:0.18,type:"square",gain:0.12});
        }
      }
    } else {
      state.vBoomT += dt;
      if (state.vBoomT > 0.8){
        state.victoryPhase = "dance";
        state.vDanceT = 0;
      }
    }

    for (let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.t += dt;
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= (1-2.2*dt);
      p.vy *= (1-2.2*dt);
      if (p.t >= p.life) particles.splice(i,1);
    }
  }

  // ===== Drawing =====
  function draw(){
    ctx.fillStyle = UI.bg1;
    ctx.fillRect(0,0,W,H);

    for (const s of stars){
      ctx.globalAlpha = 0.9*s.z;
      ctx.fillStyle = "#cfe3ff";
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }
    ctx.globalAlpha = 1;

    const theme = THEMES[state.themeIdx];

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, theme.bgTint);
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = UI.ui;
    ctx.font = "14px ui-monospace, monospace";
    ctx.fillText("ALIEN RAID", 14, 22);
    ctx.fillStyle = UI.dim;
    ctx.fillText(`SCORE ${String(state.score).padStart(6,"0")}`, 120, 22);
    ctx.fillText(`HI ${String(state.hi).padStart(6,"0")}`, 280, 22);
    ctx.fillText(`LV ${state.level}/${LAST_LEVEL}`, 368, 22);
    ctx.fillText(`LIVES ${state.lives}`, 390, 44);
    ctx.fillText(`THEME ${theme.name}`, 14, 44);
    ctx.fillText(`AUDIO ${audio.muted ? "OFF" : "ON"}`, 190, 44);

    if (state.splash > 0){
      drawSplash(state.splash, theme);
      drawAudioHintIfNeeded();
      return;
    }

    if (state.victory){
      drawVictory(theme);
      drawAudioHintIfNeeded();
      return;
    }

    if (state.bossWarning > 0){
      drawBossWarning(state.bossWarning, theme);
    }

    if (!state.gameOver){
      const blink = player.invuln > 0 ? (Math.floor(state.t*14)%2===0) : false;
      if (!blink) drawShip(player.x, player.y, UI.p);
    }

    if (boss && boss.alive){
      drawBoss(boss);
      const barW = 240, barH = 7;
      const bx = (W-barW)/2, by = 56;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(bx, by, barW, barH);
      ctx.fillStyle = UI.danger;
      ctx.fillRect(bx, by, barW*(boss.hp/boss.maxHp), barH);
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.strokeRect(bx+0.5, by+0.5, barW-1, barH-1);
    }

    for (const e of enemies){
      if (!e.alive) continue;
      drawEnemy(e.x, e.y, e.c, e.hp, e.maxHp, e.style, e.shield, e.tpFlash);
    }

    ctx.fillStyle = UI.shot;
    for (const b of bullets) ctx.fillRect(b.x-b.w/2, b.y-b.h/2, b.w, b.h);

    ctx.fillStyle = UI.danger;
    for (const b of eBullets) ctx.fillRect(b.x-b.w/2, b.y-b.h/2, b.w, b.h);

    for (const p of particles){
      const a = 1 - (p.t/p.life);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.c;
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.globalAlpha = 1;

    if (state.paused) overlay("PAUSED", "Press P to resume");
    if (state.gameOver) overlay("GAME OVER", "Press R to restart");

    drawAudioHintIfNeeded();
  }

  function drawAudioHintIfNeeded(){
    if (!audio.started){
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0,H-54,W,54);
      ctx.fillStyle = UI.ui;
      ctx.textAlign = "center";
      ctx.font = "13px ui-monospace, monospace";
      ctx.fillText("Press any key to enable sound (browser requirement)", W/2, H-22);
      ctx.textAlign = "start";
    }
  }

  function overlay(title, subtitle){
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = UI.ui;
    ctx.font = "28px ui-monospace, monospace";
    ctx.textAlign = "center";
    ctx.fillText(title, W/2, H/2 - 10);
    ctx.fillStyle = UI.dim;
    ctx.font = "14px ui-monospace, monospace";
    ctx.fillText(subtitle, W/2, H/2 + 18);
    ctx.textAlign = "start";
  }

  function drawSplash(remaining, theme){
    const total = 8.0;
    const alpha = clamp(1 - remaining/total, 0, 1);
    const blink = (Math.floor(state.t*3)%2===0);

    const c1 = theme.colors[0], c2 = theme.colors[1], c3 = theme.colors[2] || theme.colors[0];

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = c1; ctx.fillRect(0, 70, W, 6);
    ctx.fillStyle = c2; ctx.fillRect(0, 78, W, 6);
    ctx.fillStyle = c3; ctx.fillRect(0, 86, W, 6);
    ctx.globalAlpha = 1;

    ctx.textAlign = "center";
    ctx.font = "46px ui-monospace, monospace";
    ctx.fillStyle = c3; ctx.fillText("ALIEN RAID", W/2 + 2, 170 + 2);
    ctx.fillStyle = c2; ctx.fillText("ALIEN RAID", W/2 + 1, 170 + 1);
    ctx.fillStyle = UI.ui; ctx.fillText("ALIEN RAID", W/2, 170);

    ctx.fillStyle = UI.dim;
    ctx.font = "14px ui-monospace, monospace";
    ctx.fillText(`Theme: ${theme.name}`, W/2, 200);

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fillRect(66, 240, W-132, 210);
    ctx.strokeStyle = c1;
    ctx.lineWidth = 2;
    ctx.strokeRect(66.5, 240.5, W-133, 209);

    ctx.fillStyle = UI.ui;
    ctx.textAlign = "left";
    ctx.font = "15px ui-monospace, monospace";
    const x = 92, y = 274, lh = 26;

    ctx.fillText("RULES:", x, y);
    ctx.fillStyle = UI.dim;
    ctx.fillText("• Move left/right, shoot aliens.", x, y+lh);
    ctx.fillText("• Survive dives + enemy fire.", x, y+lh*2);
    ctx.fillText("• Each theme adds a new behavior.", x, y+lh*3);
    ctx.fillText("• BOSS appears every level.", x, y+lh*4);
    // (Removed the “boss music changes” instruction line)

    ctx.textAlign = "center";
    ctx.font = "14px ui-monospace, monospace";
    ctx.fillStyle = UI.ui;
    ctx.fillText("Controls: ← → / A D   Shoot: SPACE   Pause: P   Mute: M", W/2, 490);

    ctx.fillStyle = blink ? c1 : c2;
    ctx.fillText("Press B to Begin Now", W/2, 520);

    ctx.fillStyle = blink ? UI.ui : UI.dim;
    ctx.fillText(`Starting in ${Math.ceil(remaining)}...`, W/2, 548);

    const barW = 280, barH = 9;
    const bx = (W-barW)/2, by = 572;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = c1;
    ctx.fillRect(bx, by, barW*alpha, barH);
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 1;
    ctx.strokeRect(bx+0.5, by+0.5, barW-1, barH-1);

    ctx.textAlign = "start";
    ctx.restore();
  }

  function drawBossWarning(tRemain, theme){
    const blink = (Math.floor(state.t*12)%2===0);
    const shake = Math.sin(state.t*40)*2;
    const alpha = clamp(tRemain / 1.0, 0, 1);
    const c = theme.colors[2] || UI.danger;

    ctx.save();
    ctx.globalAlpha = 0.85 * (0.6 + 0.4*alpha);
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0, 90, W, 44);

    ctx.globalAlpha = blink ? 1 : 0.65;
    ctx.fillStyle = c;
    ctx.font = "20px ui-monospace, monospace";
    ctx.textAlign = "center";
    ctx.fillText("⚠ BOSS INCOMING ⚠", W/2 + shake, 120);
    ctx.textAlign = "start";
    ctx.restore();
  }

  function drawVictory(theme){
    const c1 = theme.colors[0], c2 = theme.colors[1], c3 = theme.colors[2] || theme.colors[0];
    const blink = (Math.floor(state.t*3)%2===0);

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.70)";
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = c1; ctx.fillRect(0, 70, W, 6);
    ctx.fillStyle = c2; ctx.fillRect(0, 78, W, 6);
    ctx.fillStyle = c3; ctx.fillRect(0, 86, W, 6);
    ctx.globalAlpha = 1;

    ctx.textAlign = "center";
    ctx.font = "34px ui-monospace, monospace";
    ctx.fillStyle = c2;
    ctx.fillText("YOU BEAT THE ALIENS!", W/2, 170);

    ctx.fillStyle = UI.ui;
    ctx.font = "16px ui-monospace, monospace";
    ctx.fillText(`Final Score: ${state.score}`, W/2, 205);
    ctx.fillStyle = UI.dim;
    ctx.fillText(`High Score: ${state.hi}`, W/2, 228);

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fillRect(70, 260, W-140, 240);
    ctx.strokeStyle = c1;
    ctx.lineWidth = 2;
    ctx.strokeRect(70.5, 260.5, W-141, 239);

    const ax = W/2, ay = 360;
    if (state.victoryPhase === "dance"){
      const bob = Math.sin(state.t*8)*6;
      const sway = Math.sin(state.t*6)*4;
      drawDancingAlien(ax + sway, ay + bob, c1, c2, c3);
    } else {
      ctx.globalAlpha = 0.25;
      drawDancingAlien(ax, ay, c1, c2, c3);
      ctx.globalAlpha = 1;
    }

    for (const p of particles){
      const a = 1 - (p.t/p.life);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.c;
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = blink ? c1 : c2;
    ctx.font = "16px ui-monospace, monospace";
    ctx.fillText("Press R to Restart", W/2, 540);

    ctx.restore();
    ctx.textAlign = "start";
  }

  function drawDancingAlien(x,y,c1,c2,c3){
    ctx.save();
    ctx.translate(Math.round(x), Math.round(y));
    ctx.fillStyle = c1;
    ctx.fillRect(-18, -10, 36, 20);
    ctx.fillRect(-10, -22, 20, 12);
    ctx.fillStyle = "#071021";
    ctx.fillRect(-9, -12, 6, 6);
    ctx.fillRect(3, -12, 6, 6);
    ctx.fillStyle = c2;
    ctx.fillRect(-8, 2, 16, 3);
    const arm = Math.floor(Math.sin(state.t*10)*2);
    ctx.fillStyle = c3;
    ctx.fillRect(-26, -6-arm, 8, 4);
    ctx.fillRect(18,  -6+arm, 8, 4);
    const leg = Math.floor(Math.sin(state.t*12)*2);
    ctx.fillRect(-10, 10, 6, 6+leg);
    ctx.fillRect(4,   10, 6, 6-leg);
    ctx.restore();
  }

  function drawShip(x,y,color){
    ctx.save();
    ctx.translate(Math.round(x), Math.round(y));
    ctx.fillStyle = color;
    ctx.fillRect(-2, -10, 4, 10);
    ctx.fillRect(-8, -2, 16, 6);
    ctx.fillRect(-12, 2, 24, 4);
    ctx.fillRect(-14, 6, 6, 4);
    ctx.fillRect(8, 6, 6, 4);
    ctx.fillStyle = "#e7f3ff";
    ctx.fillRect(-1, -8, 2, 3);
    ctx.restore();
  }

  function drawEnemy(x,y,color,hp,maxHp,style,shield,tpFlash){
    const theme = THEMES[state.themeIdx];
    const c1 = color;
    const c2 = theme.colors[1];
    const c3 = theme.colors[2] || theme.colors[0];

    const anim  = (Math.floor(state.t * 8) % 2);
    const blink = (Math.floor(state.t * 3) % 6) === 0;
    const tier  = Math.min(3, Math.floor((state.level-1)/2));
    const variant = enemyVariantFor(style, state.level);

    const OUT = "rgba(0,0,0,0.55)";
    const HI  = "rgba(255,255,255,0.18)";

    const px = (dx,dy,w=1,h=1, col=c1) => { ctx.fillStyle = col; ctx.fillRect(dx,dy,w,h); };
    const outlineRect = (x0,y0,w,h) => {
      ctx.fillStyle = OUT;
      ctx.fillRect(x0-1,y0-1,w+2,1);
      ctx.fillRect(x0-1,y0+h,w+2,1);
      ctx.fillRect(x0-1,y0,1,h);
      ctx.fillRect(x0+w,y0,1,h);
    };

    ctx.save();
    ctx.translate(Math.round(x), Math.round(y));

    if (tpFlash > 0){
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-14, -14, 28, 28);
      ctx.globalAlpha = 1;
    }

    switch(style){
      case 0: {
        const bodyW = (variant===0?20: variant===1?22:24);
        const bodyH = (variant===0?12: variant===1?12:14);
        const bodyX = -Math.floor(bodyW/2);
        const bodyY = -Math.floor(bodyH/2);

        outlineRect(bodyX, bodyY, bodyW, bodyH);
        px(bodyX, bodyY, bodyW, bodyH, c1);

        const domeW = (variant===0?12: variant===1?14:16);
        outlineRect(-Math.floor(domeW/2), bodyY-4, domeW, 4);
        px(-Math.floor(domeW/2), bodyY-4, domeW, 4, c1);

        const finW = (variant===2 ? 7 : 6);
        px(bodyX-2, bodyY+bodyH-2, finW, 4, c1);
        px(bodyX+bodyW-finW+2, bodyY+bodyH-2, finW, 4, c1);

        px(bodyX+2, bodyY+Math.floor(bodyH/2)-1, bodyW-4, 2, c2);

        px(-1, bodyY-6, 2, 2, c3);
        if (tier >= 1) px(-1, bodyY-8, 2, 2, c3);
        if (tier >= 2 && anim) px(-2, bodyY-10, 4, 2, c3);

        px(bodyX+2, bodyY+1, 6, 1, HI);
        px(-Math.floor(domeW/2)+1, bodyY-3, 5, 1, HI);

        ctx.fillStyle = blink ? c1 : "#071021";
        ctx.fillRect(-6,-2,3,3);
        ctx.fillRect(3,-2,3,3);

        if (tier >= 2){
          px(-9, 6, 2, 2, c3);
          px(7, 6, 2, 2, c3);
        }
        break;
      }

      case 1: {
        const w = (variant===0?22: variant===1?24:26);
        const h = (variant===0?10: variant===1?10:12);
        outlineRect(-w/2, -h/2, w, h);
        px(-w/2, -h/2, w, h, c1);

        const capW = (variant===0?16: variant===1?18:20);
        outlineRect(-capW/2, -h/2-5, capW, 5);
        px(-capW/2, -h/2-5, capW, 5, c1);

        px(-w/2-4, -2, 4, 7, c1);
        px(w/2,   -2, 4, 7, c1);
        px(-w/2-6, 0, 2, 2, c2);
        px(w/2+4,  0, 2, 2, c2);

        px(-w/2+4, -1, w-8, 3, c2);
        if (tier >= 1) px(-w/2+6, 3, w-12, 2, c3);

        for (let i=0;i<Math.min(5, tier+2);i++){
          px(-w/2+4 + i*5, h/2-1, 2, 2, (i%2?c2:c3));
        }

        if (tier >= 2){
          px(-6, 2, 12, 1, HI);
          px(-6, 3, 2, 1, HI);
          px(4, 3, 2, 1, HI);
        }

        ctx.fillStyle = blink ? c1 : "#071021";
        ctx.fillRect(-6,-2,3,3);
        ctx.fillRect(3,-2,3,3);
        break;
      }

      case 2: {
        const coreW = (variant===0?24: variant===1?26:28);
        const coreH = (variant===0?8:  variant===1?10:10);
        outlineRect(-coreW/2, -coreH/2, coreW, coreH);
        px(-coreW/2, -coreH/2, coreW, coreH, c1);

        outlineRect(-8, -coreH/2-4, 16, 4);
        px(-8, -coreH/2-4, 16, 4, c1);

        const flare = anim ? 2 : 1;
        const wingH = (variant===2 ? 12 : 10);
        px(-coreW/2-4, -2, 6, wingH, c1);
        px(coreW/2-2,  -2, 6, wingH, c1);
        if (tier >= 1){
          px(-coreW/2-6, 2, 2, flare, c2);
          px(coreW/2+4,  2, 2, flare, c2);
        }

        px(-4, -1, 8, 6, c2);
        px(-2, 1, 4, 2, c3);

        if (tier >= 2){
          px(-10, -1, 2, 2, c3);
          px(8,   -1, 2, 2, c3);
        }

        px(-coreW/2+2, -coreH/2+1, 8, 1, HI);
        px(2,          -coreH/2+1, 8, 1, HI);

        ctx.fillStyle = blink ? c1 : "#071021";
        ctx.fillRect(-6,-1,3,3);
        ctx.fillRect(3,-1,3,3);
        break;
      }

      case 3: {
        const w = (variant===0?18: variant===1?20:22);
        const h = (variant===0?14: variant===1?14:16);

        outlineRect(-w/2, -h/2, w, h);
        px(-w/2, -h/2, w, h, c1);

        const crownW = (variant===2 ? 10 : 8);
        outlineRect(-crownW/2, -h/2-5, crownW, 5);
        px(-crownW/2, -h/2-5, crownW, 5, c1);

        px(-w/2+2, -2, w-4, 2, c2);
        px(-w/2+3,  1, w-6, 2, c3);
        if (tier >= 1) px(-w/2+4, 4, w-8, 2, c2);
        if (tier >= 2) px(-w/2+5, 7, w-10, 2, c3);

        px(-w/2-5, -1, 5, 3, c1);
        px(w/2,    -1, 5, 3, c1);

        px(-w/2+2, -h/2+1, 5, 1, HI);
        px(-3, -h/2-4, 4, 1, HI);

        ctx.fillStyle = blink ? c1 : "#071021";
        ctx.fillRect(-5,-2,3,3);
        ctx.fillRect(2,-2,3,3);
        break;
      }

      case 4: {
        const w = (variant===0?20: variant===1?22:24);
        const h = (variant===0?10: variant===1?10:12);

        outlineRect(-w/2, -h/2, w, h);
        px(-w/2, -h/2, w, h, c1);

        outlineRect(-6, -h/2-5, 12, 5);
        px(-6, -h/2-5, 12, 5, c1);

        px(-w/2+1, -h/2-5, 4, 4, c3);
        px(w/2-5,  -h/2-5, 4, 4, c3);
        if (tier >= 2){
          px(-w/2-1, -h/2-7, 2, 2, c3);
          px(w/2-1,  -h/2-7, 2, 2, c3);
        }

        px(-w/2+1, h/2-1, 4, 6, c1);
        px(w/2-5,  h/2-1, 4, 6, c1);

        const pulse = anim ? 1 : 0;
        px(-4, -1, 8, 6, c2);
        px(-3+pulse, 0, 6, 4, c3);

        if (tier >= 1) px(-w/2+3, 3, 2, 1, HI);
        if (tier >= 2) px(w/2-5,  3, 2, 1, HI);
        if (tier >= 3) px(-1, 6, 2, 1, HI);

        ctx.fillStyle = blink ? c1 : "#071021";
        ctx.fillRect(-5,-2,2,2);
        ctx.fillRect(3,-2,2,2);
        break;
      }

      case 5: {
        const w = (variant===0?20: variant===1?22:24);
        const h = (variant===0?12: variant===1?12:14);

        outlineRect(-w/2, -h/2, w, h);
        px(-w/2, -h/2, w, h, c1);

        outlineRect(-2, -h/2-6, 4, 6);
        px(-2, -h/2-6, 4, 6, c1);
        px(-1, -h/2-8, 2, 2, c2);

        px(-w/2-4, -1, 4, 4, c1);
        px(w/2,    -1, 4, 4, c1);
        px(-w/2-5,  0, 2, 2, c2);
        px(w/2+3,   0, 2, 2, c2);

        px(-w/2+2, -2, w-4, 1, c3);
        if (tier >= 1) px(-w/2+4, 1, w-8, 1, c2);
        if (tier >= 2) px(-w/2+6, 4, w-12, 1, c3);
        if (tier >= 3){
          px(-w/2+2, 6, w-4, 1, c2);
          px(-w/2+8, -6, w-16, 1, c3);
        }

        px(-w/2+2, h/2-4, w-4, 4, c1);
        px(-w/2+3, h/2-3, w-6, 1, c3);
        px(-w/2+3, h/2-1, w-6, 1, c3);

        ctx.fillStyle = blink ? c1 : "#e7f3ff";
        ctx.fillRect(-5,-2,2,2);
        ctx.fillRect(3,-2,2,2);

        ctx.fillStyle = c2;
        ctx.fillRect(-1, 2, 2, 2);
        break;
      }
    }

    if (shield){
      ctx.strokeStyle = "rgba(231,243,255,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, 14, 0, Math.PI*2);
      ctx.stroke();

      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = "#e7f3ff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0, 0, 16, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (maxHp > 1){
      ctx.fillStyle = "#e7f3ff";
      const pips = Math.min(4, maxHp-1);
      for (let i=0;i<pips;i++) ctx.fillRect(-7+i*5, -16, 3, 3);
    }

    if (tier > 0){
      const stripes = Math.min(3, tier);
      ctx.fillStyle = c2;
      for (let i=0;i<stripes;i++){
        ctx.fillRect(-13 + i*4, 12, 3, 1);
      }
    }

    ctx.restore();
  }

  function drawBoss(b){
    ctx.save();
    ctx.translate(Math.round(b.x), Math.round(b.y));

    if (b.telegraph > 0){
      ctx.globalAlpha = 0.45;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-46, -26, 92, 52);
      ctx.globalAlpha = 1;
    }
    if (b.flash > 0){
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-48, -24, 96, 48);
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = b.c1;
    ctx.fillRect(-38, -14, 76, 28);
    ctx.fillRect(-26, -24, 52, 10);
    ctx.fillRect(-46, -6, 14, 20);
    ctx.fillRect(32, -6, 14, 20);

    ctx.fillStyle = b.c2;
    ctx.fillRect(-18, -10, 36, 20);
    ctx.fillRect(-12, 10, 24, 7);

    ctx.fillStyle = b.c3;
    ctx.fillRect(-30, -2, 8, 10);
    ctx.fillRect(22, -2, 8, 10);

    ctx.fillStyle = "#071021";
    ctx.fillRect(-16, -2, 7, 5);
    ctx.fillRect(9, -2, 7, 5);

    ctx.fillStyle = "#e7f3ff";
    ctx.fillRect(-14, 5, 28, 2);

    ctx.restore();
  }

})();
</script>
</body>
</html>